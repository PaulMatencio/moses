// CreatePng project main.go
package main

import (
	"bytes"
	"container/ring"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"os/user"
	"path"
	"strconv"
	"strings"
	"time"
	"user/base64"
	"user/bns"
	"user/files"
	"user/sproxyd"
)

func usage() {
	usage := "\nFunction=> Create png/Tiff images from directory generated by St33toScality -a CreateFile\n\nUsage: CreateDocument -c config -w png/tiff -a [create/update/delete/updMetadata/getUrl/Test] -i inputdir\n\nDefault Options:\n"
	fmt.Println(usage)
	flag.PrintDefaults()
	os.Exit(2)
}

var (
	action   string
	inputDir string
	config   string
	what     string
)

func main() {

	const (
		// base_url string = "http://luo001t.internal.epo.org:81/proxy/chord/bns/"
		LAYOUT    = "Jan 2, 2006 at 3:04pm (MST)"
		PNG       = "png"
		TIFF      = "Tiff"
		CONTAINER = "Container"
		USERMD    = "Usermd"
	)

	flag.Usage = usage
	flag.StringVar(&action, "a", "", "")
	flag.StringVar(&inputDir, "i", "", "")
	flag.StringVar(&config, "c", "", "")
	flag.StringVar(&what, "w", "png", "")

	flag.Parse()
	if len(action) == 0 {
		usage()
	}

	//client := &http.Client{}
	if what != "png" &&  what != "tiff" {

		fmt.Println("Invalid type, should be png or tiff")
		os.Exit(2)

	}
	ct := "image/"+what
	//sep	 	:= string(os.PathSeparator)
	cpath, _ := user.Current()
	input_dir := path.Join(cpath.HomeDir, inputDir)
	png_path := path.Join(input_dir, PNG)
	tiff_path := path.Join(input_dir, TIFF)
	container_path := path.Join(input_dir, CONTAINER)
	usermd_path := path.Join(input_dir, USERMD)
	png_exist, _ := files.Exists(png_path)
	container_exist, _ := files.Exists(container_path)

	if action == PNG && !png_exist {
		fmt.Println(png_path, "Does not exist")
		os.Exit(2)
	}
	var (
		url      string
		buf      []byte
		filesize int64
		t_pages  int
		resp     *http.Response
	)
	time1 := time.Now()

	if len(config) != 0 {
		err := sproxyd.SetProxydHost(config)
		if err != nil {
			fmt.Println(err)
			os.Exit(2)
		}
	}
	/* Create the ring of sproxyd servers */

	r := ring.New(len(sproxyd.Host)) // r  is a pointer to  the ring
	for i := 0; i < r.Len(); i++ {
		r.Value = sproxyd.Host[i]
		// fmt.Println(r.Value)
		r = r.Next()
	}
	if container_exist {
		cont_ent, _ := ioutil.ReadDir(container_path)
		for _, container_file := range cont_ent {

			base_url := r.Value.(string)
			if what == TIFF { base_url = base_url + "bns/"
			} else {
				base_url = base_url + what + "/"
			}
			r = r.Next()

			//os.fileInfo
			var err error
			var containermd map[string]string
			var encoded_containermd string
			container_fn := container_file.Name()
			split := strings.Split(container_fn, ".")
			docid := split[0]
			doc_fn := path.Join(container_path, container_fn)
			if split[1] != "json" {
				fmt.Println(container_fn, " is not a container")
				continue
			}

			/*  Read container metadata */
			fmt.Println(doc_fn)
			buf, err = ioutil.ReadFile(doc_fn)
			if err != nil {
				fmt.Println(err)
				continue

			} else {
				//var containermd map[string]interface{}
				err := json.Unmarshal(buf, &containermd)
				if err != nil {
					fmt.Println(err)

				}
			}
			url = base_url + docid
			// Create the container
			var putheader map[string]string
			if action == "create" || action == "update" {
				encoded_containermd, _ = base64.Encode64(containermd)
				putheader = map[string]string{
					"Usermd":       encoded_containermd,
					"Content-Type": ct,
				}

			}
			client := &http.Client{}

			switch action {

			case "create":
				buf0 := new(bytes.Buffer)
				time1 = time.Now()
				if resp, err = sproxyd.PutObject(client, url, buf0.Bytes(), putheader); err != nil {
					fmt.Println(err)
					continue
				}
				switch resp.StatusCode {
				case 200:
					
					fmt.Println(resp.StatusCode,url, resp.Header["X-Scal-Ring-Key"],  "Duration=",time.Since(time1))
				case 412:
					fmt.Println(resp.StatusCode, "key=", resp.Header["X-Scal-Ring-Key"], "already exist")
				case 422:
					fmt.Println(resp.StatusCode, resp.Header["X-Scal-Ring-Status"])
				default:
					fmt.Println(resp.StatusCode)
					os.Exit(2) // metadata must be written first
				}
				resp.Body.Close()

			case "update":
				time1 = time.Now()
				if resp, err = sproxyd.PutObject(client, url, buf, putheader); err != nil {
					fmt.Println(err)
					continue
				}
				switch resp.StatusCode {
				case 200:
					fmt.Println("OK", url, resp.Header["X-Scal-Ring-Key"], "Duration=",time.Since(time1))
				case 404:
					fmt.Println(resp.StatusCode, url, " not found")
				case 412:
					fmt.Println(resp.StatusCode, url, "key=", resp.Header["X-Scal-Ring-Key"], " does not exist")
		 		case 422:
					fmt.Println(resp.StatusCode, resp.Header["X-Scal-Ring-Status"])
				default:
					fmt.Println(url, resp.StatusCode, time.Since(time1))
				}
				resp.Body.Close()

			case "delete":

				time1 = time.Now()
				deleteHeader := map[string]string{}
				var resp *http.Response
				client := &http.Client{}
				if resp, err = sproxyd.DeleteObject(client, url, deleteHeader); err != nil {
					fmt.Println(err)
					resp.Body.Close()
					break
				}
				switch resp.StatusCode {
				case 200:
				
					fmt.Println(resp.StatusCode, url, resp.Header["X-Scal-Ring-Key"], "Duration=",time.Since(time1) )
				case 404:
					fmt.Println(resp.StatusCode, url, " not found")
				case 412:
					fmt.Println(resp.StatusCode, "key=", resp.Header["X-Scal-Ring-Key"], " does not exist")
				case 422:
					fmt.Println(resp.StatusCode, resp.Header["X-Scal-Ring-Status"])
				default:
					fmt.Println(resp.StatusCode)
				}

				//fmt.Println(resp.StatusCode, resp.Header["X-Scal-Ring-Key"])
				resp.Body.Close()
			case "Test":
				fmt.Println("Container:", url,ct)
			default:
			}

			// create other objects
			t_pages, _ = bns.GetPageNumber_1(containermd)
			urls := make([]string, t_pages)
			for d := 1; d <= t_pages; d++ {
				host := r.Value
				r = r.Next()
				var page string
				switch {
				case d < 10:
					page = "000" + strconv.Itoa(d)
				case d >= 10 && d < 100:
					page = "00" + strconv.Itoa(d)
				case d >= 100 && d < 1000:
					page = "0" + strconv.Itoa(d)
				default:
				}
				url = base_url + docid + "_" + page
				var (
					doc_path string
					usermd   map[string]string
				)
				doc_fn := docid + "_" + page + "." + what
				usermd_fn := docid + "_" + page + ".json"
				if what == PNG {
					doc_path = png_path
				} else {
					doc_path = tiff_path
				}
				/* read PNG/TIFF files */
				if action != "delete" {
					/* Read the images */
					doc_file := path.Join(doc_path, doc_fn)
					fmt.Println("Reading file", doc_file)
					buf, err = ioutil.ReadFile(doc_file) // BUF
					if err != nil {
						fmt.Println(err, "Reading", doc_file)

					}
					/* Read user  metadata */
					usermd_file := path.Join(usermd_path, usermd_fn)
					usermd_buf, err := ioutil.ReadFile(usermd_file)
					if err != nil {
						fmt.Println("Reading", usermd_file, err)
						continue
					} else {
						err := json.Unmarshal(usermd_buf, &usermd)
						if err != nil {
							fmt.Println(err)
							continue
						}
					}
				}
				urls[d-1] = host.(string) + docid + "_" + page

				switch action {
				case "Test":
					fmt.Println(url,ct)
				case "create":
					time1 = time.Now()
					usermd["PageSize"] = strconv.Itoa(len(buf))
					encoded_usermd, _ := base64.Encode64(usermd)
					 
					putheader := map[string]string{
						"Usermd":       encoded_usermd,
						"Content-Type": ct,
					}
					client := &http.Client{}
					var resp *http.Response
					if resp, err = sproxyd.PutObject(client, url, buf, putheader); err != nil {
						fmt.Println(err)
						resp.Body.Close()
					}

					switch resp.StatusCode {
					case 200:
						duration:= time.Since(time1)
						fmt.Println(resp.StatusCode,url, resp.Header["X-Scal-Ring-Key"], "MB/sec=", 1000*float64(filesize)/float64(duration), "Duration=", duration)
					case 412:
						fmt.Println(resp.StatusCode, "key=", resp.Header["X-Scal-Ring-Key"], "already exist")
					case 422:
						fmt.Println(resp.StatusCode, resp.Header["X-Scal-Ring-Status"])
					default:
						fmt.Println(resp.StatusCode)
					}
					resp.Body.Close()

				case "update":
					time1 = time.Now()
					usermd["DocSize"] = strconv.Itoa(len(buf))
					usermd["update"] = "Data"
					usermd["Time_of_update"] = time1.UTC().Format(LAYOUT)
					encoded_usermd, _ := base64.Encode64(usermd)
					putheader := map[string]string{
						"Usermd":       encoded_usermd,
						"Content-Type": ct,
					}
					var resp *http.Response
					client := &http.Client{}
					if resp, err = sproxyd.UpdObject(client, url, buf, putheader); err != nil {
						fmt.Println(err)
						resp.Body.Close()
						break
					}

					switch resp.StatusCode {
					case 200:
						duration:= time.Since(time1)
						fmt.Println("OK", resp.Header["X-Scal-Ring-Key"], "MB/sec=", 1000*float64(filesize)/float64(duration), "Duration=",duration  )
					case 404:
						fmt.Println(resp.StatusCode, url, " not found")
					case 412:
						fmt.Println(resp.StatusCode, "key=", resp.Header["X-Scal-Ring-Key"], " does not exist")
					case 422:
						fmt.Println(resp.StatusCode, resp.Header["X-Scal-Ring-Status"])
					default:
						fmt.Println(resp.StatusCode)
					}
					resp.Body.Close()

				case "delete":
					time1 = time.Now()
					deleteHeader := map[string]string{}
					var resp *http.Response
					client := &http.Client{}
					if resp, err = sproxyd.DeleteObject(client, url, deleteHeader); err != nil {
						fmt.Println(err)
						resp.Body.Close()
						break
					}
					switch resp.StatusCode {
					case 200:
						
						fmt.Println(url, "OK", resp.Header["X-Scal-Ring-Key"], "Duration=", time.Since(time1))
					case 404:
						fmt.Println(resp.StatusCode, url, " not found")
					case 412:
						fmt.Println(resp.StatusCode, "key=", resp.Header["X-Scal-Ring-Key"], " does not exist")
					case 422:
						fmt.Println(resp.StatusCode, resp.Header["X-Scal-Ring-Status"])
					default:
						fmt.Println(resp.StatusCode)
					}

					//fmt.Println(resp.StatusCode, resp.Header["X-Scal-Ring-Key"])
					resp.Body.Close()

				case "updMetadata":
					//New user metadata
					time1 := time.Now()
					usermd["update"] = "Metadata"
					usermd["Time_of_update"] = time1.UTC().Format(LAYOUT)
					encoded_usermd, _ := base64.Encode64(usermd)
					updHeader := map[string]string{
						"Usermd":       encoded_usermd,
						"Content-Type": ct,
					}
					client := &http.Client{}
					resp, err := sproxyd.UpdMetadata(client, url, updHeader)
					if err != nil {
						fmt.Println(err)
						break
					}
					switch resp.StatusCode {
					case 200:
						
						fmt.Println("OK", resp.Header["X-Scal-Ring-Key"],"duration=",time.Since(time1))
					case 404:
						fmt.Println(resp.StatusCode, url, " not found")
					case 412:
						fmt.Println(resp.StatusCode, "key=", resp.Header["X-Scal-Ring-Key"], " does not exist")
					case 422:
						fmt.Println(resp.StatusCode, resp.Header["X-Scal-Ring-Status"])
					default:
						fmt.Println(resp.StatusCode)
					}
					resp.Body.Close()

				default:
					fmt.Println("wrong Request, please use -help to check the -a options")

				} // switch
			}
		} // FOR

	} else {
		fmt.Println(container_path, "Container Directory is missing")
		os.Exit(2)
	}
}

