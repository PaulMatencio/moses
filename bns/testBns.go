package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	bns "moses/bns/lib"
	directory "moses/directory/lib"
	sproxyd "moses/sproxyd/lib"
	base64 "moses/user/base64j"
	goLog "moses/user/goLog"
	"net/http"
	"os"
	"os/user"
	"path"
	"strconv"
	"strings"
	"time"
	"user/files"

	hostpool "github.com/bitly/go-hostpool"
)

func usage() {
	usage := "\nFunction=> Load Tiff images from directory generated by St33toFiles \n\nUsage: bns -c <config> -w <tiff> -i <inputdir> -a <putObject/updObject/deleteObject/Test> -C <0/1> -T <testname> -D <domain> -n <#domain> " +
		"-x <0/1>" +
		"\n\nOptions" +
		"\n-a <action>  putObject: Load images(urls) to Scality Ring, Test: Print the urls to the <info output log> file in the directory indicated by <-T testname>)" +
		"\n-c <config>, sproxyd configfile;default file is [$HOME/sproxyd/storage]" +
		"\n-i <inputdir> the input directory must a child of the $HOME directory" +
		"\n-x <0/1> 1=>output for postprocessing with SAS,default is [0]\n-C <0/1> 1=> Check consistency,default is [0]. WARNING:Not yet implemented for multithreading, use TestConsitency program instead" +
		"\n-T <testname> arbitrary name,default is [LoadImages]. <testname> is used by the programe to create a child directory for output logs; the parent directory is defined on the <config> file" +
		"\n-D <domain> used to load multiple times a same dcoument with different path-name, default is [0]. It should be provided it and can be [0:infinite number]\n-i <inputdir> directory generated by ST33toFiles,no default" +
		"\n-n <#domain> For every Tiff images read from the input directory indicated b -i <[inputdir]/Tiff>, it will be loaded to multiple domains [<domain>:<domain+#domain>]" +
		"\n\nDefault Options:\n"

	fmt.Println(usage)
	flag.PrintDefaults()
	os.Exit(2)
}

var (
	action, inputDir, config, domain, nDomain, what, logPath, trace string
	Trace                                                           bool
	excel                                                           string
	application                                                     string
	testname                                                        string
	check_consistency                                               string
	consistency                                                     bool
	pid                                                             int
	hostname                                                        string
	timeout                                                         time.Duration
)

type Response struct {
	Err  error
	Resp *http.Response
}

//var urls = []string

type HttpResponse struct {
	url      string
	response *http.Response
	size     int
	err      error
}

func main() {

	const (
		// base_url string = "http://luo001t.internal.epo.org:81/proxy/chord/bns/"
		LAYOUT    = "Jan 2, 2006 at 3:04pm (MST)"
		PNG       = "png"
		TIFF      = "Tiff"
		CONTAINER = "Container"
		USERMD    = "Usermd"
	)
	var (
		url                                                                                   string
		buf                                                                                   []byte
		page_size, doc_size, total_size, tok, treq, total_pages_to_write, total_pages_written int64
		t_pages, req, ok, pages_to_write, pages_written                                       int
	)

	flag.Usage = usage
	flag.StringVar(&action, "a", "", "")
	flag.StringVar(&inputDir, "i", "", "")
	flag.StringVar(&config, "c", "storage", "")
	flag.StringVar(&check_consistency, "C", "0", "")
	flag.StringVar(&domain, "D", "0", "")
	flag.StringVar(&nDomain, "n", "1", "")
	flag.StringVar(&trace, "t", "0", "")             // Trace
	flag.StringVar(&testname, "T", "LoadImages", "") // Test name
	flag.StringVar(&excel, "x", "0", "")             // for SAS or Excel
	flag.StringVar(&what, "w", "tiff", "")

	flag.Parse()
	if len(action) == 0 {
		usage()
	}
	Trace, _ = strconv.ParseBool(trace)
	directory.SetCPU("100%")
	//client := &http.Client{}
	if what != "png" && what != "tiff" {
		fmt.Println("ERROR:Invalid type, should be png or tiff")
		os.Exit(2)
	}
	domain0 := domain
	domains := domain0 /* save */
	domain = domain + "/"
	numdomain, _ := strconv.Atoi(nDomain)
	pathx := make([]string, numdomain)
	pathy := make([]string, numdomain)
	application = "putImages"
	consistency = false
	timeout = time.Duration(30 * numdomain)
	ct := "image/" + what // content type
	//sep 	    := string(os.PathSeparator)
	cpath, _ := user.Current()
	input_dir := path.Join(cpath.HomeDir, inputDir)
	png_path := path.Join(input_dir, PNG)
	tiff_path := path.Join(input_dir, TIFF)
	container_path := path.Join(input_dir, CONTAINER)
	pagmd_path := path.Join(input_dir, USERMD)
	png_exist, _ := files.Exists(png_path)
	container_exist, _ := files.Exists(container_path)

	if action == PNG && !png_exist {
		fmt.Println("ERROR:", png_path, "Does not exist")
		os.Exit(2)
	}
	if action == "PutObject" && check_consistency == "1" {
		consistency = true
	}
	pid = os.Getpid()
	hostname, _ = os.Hostname()
	if testname != "" {
		testname += string(os.PathSeparator)
	}
	if len(config) != 0 {

		if Config, err := sproxyd.GetConfig(config); err == nil {
			logPath = Config.GetLogPath()
			sproxyd.SetNewProxydHost(Config)
			sproxyd.Driver = Config.GetDriver()
			fmt.Println("INFO: Using config Hosts", sproxyd.Host, sproxyd.Driver, logPath)
		} else {
			sproxyd.HP = hostpool.NewEpsilonGreedy(sproxyd.Host, 0, &hostpool.LinearEpsilonValueCalculator{})
			fmt.Println(err, "WARNING: Using default Hosts:", sproxyd.Host)
		}
	}
	// init logging

	if logPath == "" {
		fmt.Println("WARNING: Using default logging")
		goLog.Init(ioutil.Discard, os.Stdout, os.Stdout, os.Stderr)
	} else {

		// mkAll dir
		logPath = logPath + string(os.PathSeparator) + testname
		if !files.Exist(logPath) {
			_ = os.MkdirAll(logPath, 0755)

		}
		traceLog := logPath + application + "_trace.log"
		infoLog := logPath + application + "_info.log"
		warnLog := logPath + application + "_warning.log"
		errLog := logPath + application + "_error.log"

		trf, err1 := os.OpenFile(traceLog, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0744)
		inf, err2 := os.OpenFile(infoLog, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0744)
		waf, err3 := os.OpenFile(warnLog, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0744)
		erf, err4 := os.OpenFile(errLog, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0744)

		defer trf.Close()
		defer inf.Close()
		defer waf.Close()
		defer erf.Close()

		if err1 != nil || err2 != nil || err3 != nil || err4 != nil {
			goLog.Init(ioutil.Discard, os.Stdout, os.Stdout, os.Stderr)
			goLog.Warning.Println(err1, err2, err3, err3)
			goLog.Warning.Println(hostname, pid, "Using default logging")
		} else {
			if trace == "0" {
				goLog.Init(ioutil.Discard, io.Writer(inf), io.Writer(waf), io.Writer(erf))

			} else {
				goLog.Init(io.Writer(trf), io.Writer(inf), io.Writer(waf), io.Writer(erf))
				goLog.Trace.Println(hostname, pid, "Start", application, action)
			}
		}
	}

	//goLog.Init0(logPath, testname, application, action, Trace)
	start := time.Now()

	if container_exist {

		total_pages := 0 /* the number of pages */
		total_elapstm_since_start := time.Since(time.Now())
		total_elapstm := time.Since(time.Now())
		total_docs := 0 /* the number of documents folder */
		total_size = 0  /* the size of all the documents of the folder */

		tok = 0
		treq = 0

		goLog.Info.Println("Start", application, "domain=", domain0)
		cont_ent, _ := ioutil.ReadDir(container_path)

		/* lop on the number of documents directories */

		for _, container_file := range cont_ent {

			var elapse time.Duration
			elapstm := time.Since(time.Now())
			total_docs += 1
			var err error
			docmeta := &bns.Docmeta{}
			container_fn := container_file.Name()
			split := strings.Split(container_fn, ".")
			docid := split[0]
			doc_fn := path.Join(container_path, container_fn)

			if split[1] != "json" {
				goLog.Error.Println(container_fn, " is not a container")
				continue
			}

			/*  Read container metadata */
			goLog.Trace.Println(doc_fn)
			//time0 := time.Now()
			buf, err = ioutil.ReadFile(doc_fn)
			if err != nil {
				goLog.Error.Println(err)
				continue

			} else {
				err := json.Unmarshal(buf, &docmeta)
				if err != nil {
					goLog.Error.Println(err)

				}
			}
			domain0 = domains
			d0, _ := strconv.Atoi(domain0)

			for i := 0; i < len(pathx); i++ {
				base_url := sproxyd.Proxy + "/" + sproxyd.Driver + "/bns/"
				pathx[i] = base_url + domain0 + "/" + docid
				d0 += 1
				domain0 = strconv.Itoa(d0)
			}
			domain0 = domains
			// Create the container

			var putheader map[string]string

			ok = 0
			req = len(pathx)
			time1 := time.Now()

			switch action {

			case "putObject":
				var (
					c   []byte
					err error
				)
				if c, err = json.Marshal(&docmeta); err == nil {
					putheader = map[string]string{
						"Usermd":       base64.Encode64(c),
						"Content-Type": ct,
					}
				} else {
					break
				}

				if Trace {
					d, _ := base64.Decode64(base64.Encode64(c))
					goLog.Trace.Println(string(c), string(d))
				}

				buf0 := new(bytes.Buffer)
				results := bns.AsyncHttpPut(pathx, buf0.Bytes(), putheader)
				elapse = time.Since(time1)

				for _, result := range results {

					if result.Err != nil {
						goLog.Trace.Printf("%s %d %s status: %s\n", hostname, pid, result.Url, result.Err)
						continue
					}
					resp := result.Response
					goLog.Trace.Printf("%s %d %s status: %s\n", hostname, pid, result.Url,
						resp.Status)
					switch resp.StatusCode {
					case 200:
						goLog.Trace.Println(hostname, pid, url, resp.Status, resp.Header["X-Scal-Ring-Key"], "Elapse=", elapse)
						ok += 1
					case 412:
						goLog.Warning.Println(hostname, pid, url, resp.Status, "key=", resp.Header["X-Scal-Ring-Key"], "already exist")
					case 422:
						goLog.Error.Println(hostname, pid, url, resp.Status, resp.Header["X-Scal-Ring-Status"])
					default:
						goLog.Warning.Println(hostname, pid, url, resp.Status, "Elapse=", elapse)
						os.Exit(2) // metadata must be written first
					}

					resp.Body.Close()
				}
				if ok < req {
					goLog.Warning.Println(hostname, pid, docid, ok, req, "ok < req => Check Warning or Error log")

				}
			case "updObject":
				var (
					c   []byte
					err error
				)
				if c, err = json.Marshal(&docmeta); err == nil {
					putheader = map[string]string{
						"Usermd":       base64.Encode64(c),
						"Content-Type": ct,
					}
				} else {
					break
				}
				if Trace {
					d, _ := base64.Decode64(base64.Encode64(c))
					goLog.Trace.Println(string(c), string(d))
				}
				buf0 := new(bytes.Buffer)
				results := bns.AsyncHttpUpdate(pathx, buf0.Bytes(), putheader)
				elapse = time.Since(time1)

				for _, result := range results {
					if result.Err != nil {
						goLog.Trace.Printf("%s %d %s status: %s\n", hostname, pid, result.Url, result.Err)
						continue
					}

					resp := result.Response
					goLog.Trace.Printf("%s %d %s status: %s\n", hostname, pid, result.Url,
						resp.Status)
					switch resp.StatusCode {
					case 200:
						goLog.Trace.Println(hostname, pid, url, resp.Status, resp.Header["X-Scal-Ring-Key"], "Elapse=", elapse)
						ok += 1
					case 412:
						goLog.Warning.Println(hostname, pid, url, resp.Status, "key=", resp.Header["X-Scal-Ring-Key"], "Does not exist")
					case 422:
						goLog.Error.Println(hostname, pid, url, resp.Status, resp.Header["X-Scal-Ring-Status"])
					default:
						goLog.Warning.Println(hostname, pid, url, resp.Status, "Elapse=", elapse)
						os.Exit(2) // metadata must be written first
					}

					resp.Body.Close()
				}
				if ok < req {
					goLog.Warning.Println(hostname, pid, docid, ok, req, "ok < req => Check Warning or Error log")

				}
			case "deleteObject":

				deleteheader := map[string]string{}
				results := bns.AsyncHttpDelete(pathx, deleteheader)
				elapse = time.Since(time1)

				for _, result := range results {
					if result.Err != nil {
						goLog.Trace.Printf("%s %d %s status: %s\n", hostname, pid, result.Url, result.Err)
						continue
					}
					resp := result.Response
					goLog.Trace.Printf("%s %d %s status: %s\n", hostname, pid, result.Url, resp.Status)

					switch resp.StatusCode {
					case 200:
						goLog.Trace.Println(hostname, pid, url, resp.Status, resp.Header["X-Scal-Ring-Key"], "Elapse=", elapse)
						ok += 1

					case 404:
						goLog.Warning.Println(hostname, pid, url, resp.Status, "key=", resp.Header["X-Scal-Ring-Key"], "Not Found")
					case 412:
						goLog.Warning.Println(hostname, pid, url, resp.Status, "key=", resp.Header["X-Scal-Ring-Key"], "Does not exist")
					case 422:
						goLog.Error.Println(hostname, pid, url, resp.Status, resp.Header["X-Scal-Ring-Status"])
					default:
						goLog.Warning.Println(hostname, pid, url, resp.Status, "Elapse=", elapse)
						os.Exit(2) // metadata must be written first
					}

					resp.Body.Close()
				}
				if ok < req {
					goLog.Warning.Println(hostname, pid, docid, ok, req, "ok < req => Check Warning or Error log")

				}

			case "Test":
				for _, path := range pathx {
					ok++
					elapse = time.Since(time1)
					hpool := sproxyd.HP.Get()
					curl := hpool.Host() + path
					goLog.Info.Println(hostname, pid, action, "Test", curl)
					hpool.Mark(nil)
				}

			default:
			}

			treq += int64(req)
			tok += int64(ok)
			elapstm += elapse

			// create the other objects
			t_pages, _ = docmeta.GetPageNumber()
			doc_path := path.Join(tiff_path, docid)
			pagmd_path := path.Join(pagmd_path, docid)
			doc_entry, _ := ioutil.ReadDir(doc_path)
			t1_pages := len(doc_entry)
			if t1_pages != t_pages {
				goLog.Warning.Println(hostname, pid, "Number of Tiff images not egal number of pages", t1_pages, t_pages)
			}

			doc_size = 0

			total_pages += t_pages

			for _, doc_files := range doc_entry {
				/* loop on the number of pages for each directory (document) */
				pagmd := &bns.Pagmeta{}
				page := doc_files.Name()
				page0 := strings.Split(page, ".")[0] // remove .tiff type

				for k, v := range pathx {
					pathy[k] = v + "/" + page0
				}

				pages_to_write = t_pages * len(pathx)

				/* Read the  images */
				time1 = time.Now()

				doc_file := path.Join(doc_path, page)
				goLog.Trace.Println(hostname, pid, "Reading image file", doc_file)
				buf, err = ioutil.ReadFile(doc_file) // BUF
				if err != nil {
					goLog.Warning.Println(hostname, pid, err, "Reading", doc_file)
				}

				/* Read user  object metadata */
				pagmd_fn := page0 + ".json"
				pagmd_file := path.Join(pagmd_path, pagmd_fn)
				goLog.Trace.Println(hostname, pid, "Reading user metatdata file", pagmd_file)
				pagmd_buf, err := ioutil.ReadFile(pagmd_file)
				if err != nil {
					goLog.Trace.Println(hostname, pid, "Reading", pagmd_file, err)
					continue
				} else {
					err := json.Unmarshal(pagmd_buf, &pagmd)
					if err != nil {
						goLog.Error.Println(err)
						continue
					}
				}

				//urls[d] = host.(string) + domain + docid + "/" + page

				page_size = int64(len(buf))
				doc_size += page_size

				req = len(pathy)

				ok = 0
				pages_written = 0

				switch action {
				case "Test":

					for _, path := range pathy {
						hpool := sproxyd.HP.Get()
						url := hpool.Host() + path
						ok += 1
						pages_written += t_pages
						goLog.Info.Println(hostname, pid, action, url, len(doc_entry), t_pages)
						hpool.Mark(nil)
					}
					elapse = time.Since(time1)

					//elapse = time.Since(time0)
				case "putObject":
					var (
						c   []byte
						err error
					)
					time1 = time.Now()
					pagmd.Page_size = strconv.Itoa(len(buf))

					if c, err = json.Marshal(&pagmd); err == nil {
						putheader = map[string]string{
							"Usermd":       base64.Encode64(c),
							"Content-Type": ct,
						}
					} else {
						break
					}

					if Trace {
						d, _ := base64.Decode64(base64.Encode64(c))
						goLog.Trace.Println(string(c), string(d))
					}

					results := bns.AsyncHttpPut(pathy, buf, putheader)

					elapse = time.Since(time1)

					for _, result := range results {

						if result.Err != nil {
							goLog.Trace.Printf("%s %d %s status: %s\n", hostname, pid, result.Url, result.Err)
							continue
						}
						resp := result.Response
						if resp != nil {
							goLog.Trace.Printf("%s %d %s status: %s\n", hostname, pid, result.Url,
								result.Response.Status)
						} else {
							goLog.Error.Printf("%s %d %s %s %s", hostname, pid, result.Url, action, "failed")
							continue
						}
						// resp := result.response
						switch resp.StatusCode {
						case 200:
							goLog.Trace.Println(hostname, pid, url, resp.Status, resp.Header["X-Scal-Ring-Key"], "Elapse=", elapse)
							ok += 1
							pages_written += t_pages
						case 412:

							goLog.Warning.Println(hostname, pid, url, resp.Status, "key=", resp.Header["X-Scal-Ring-Key"], "already exist")

						case 422:
							goLog.Error.Println(hostname, pid, url, resp.Status, resp.Header["X-Scal-Ring-Status"])
						default:
							goLog.Warning.Println(hostname, pid, url, resp.Status, "Elapse=", elapse)
						}
						resp.Body.Close()
					}

					if ok < req {
						goLog.Warning.Println(hostname, pid, docid, ok, req, "#ok < #req => Check Warning or Error log")
					}

				case "updObject":
					var (
						c   []byte
						err error
					)
					time1 = time.Now()
					pagmd.Page_size = strconv.Itoa(len(buf))
					if c, err = json.Marshal(&pagmd); err == nil {
						putheader = map[string]string{
							"Usermd":       base64.Encode64(c),
							"Content-Type": ct,
						}
					} else {
						break
					}

					if Trace {
						d, _ := base64.Decode64(base64.Encode64(c))
						goLog.Trace.Println(string(c), string(d))
					}
					results := bns.AsyncHttpUpdate(pathy, buf, putheader)
					elapse = time.Since(time1)

					for _, result := range results {
						if result.Err != nil {
							goLog.Trace.Printf("%s %d %s status: %s\n", hostname, pid, result.Url, result.Err)
							continue
						}
						resp := result.Response
						if resp != nil {
							goLog.Trace.Printf("%s %d %s status: %s\n", hostname, pid, result.Url,
								result.Response.Status)
						} else {
							goLog.Error.Printf("%s %d %s %s %s", hostname, pid, result.Url, action, "failed")
							continue
						}
						// resp := result.response
						switch resp.StatusCode {
						case 200:
							goLog.Trace.Println(hostname, pid, url, resp.Status, resp.Header["X-Scal-Ring-Key"], "Elapse=", elapse)
							ok += 1
							pages_written += t_pages
						case 412:

							goLog.Warning.Println(hostname, pid, url, resp.Status, "key=", resp.Header["X-Scal-Ring-Key"], "already exist")

						case 422:
							goLog.Error.Println(hostname, pid, url, resp.Status, resp.Header["X-Scal-Ring-Status"])
						default:
							goLog.Warning.Println(hostname, pid, url, resp.Status, "Elapse=", elapse)
						}
						resp.Body.Close()
					}

					if ok < req {
						goLog.Warning.Println(hostname, pid, docid, ok, req, "#ok < #req => Check Warning or Error log")
					}

				case "deleteObject":
					time1 = time.Now()
					deleteheader := map[string]string{}
					results := bns.AsyncHttpDelete(pathy, deleteheader)
					elapse = time.Since(time1)

					for _, result := range results {
						if result.Err != nil {
							goLog.Trace.Printf("%s %d %s status: %s\n", hostname, pid, result.Url, result.Err)
							continue
						}
						resp := result.Response
						goLog.Trace.Printf("%s %d %s status: %s\n", hostname, pid, result.Url,
							resp.Status)
						switch resp.StatusCode {
						case 200:
							goLog.Trace.Println(hostname, pid, url, resp.Status, resp.Header["X-Scal-Ring-Key"], "Elapse=", elapse)
							ok += 1
						case 404:
							goLog.Warning.Println(hostname, pid, url, resp.Status, "key=", resp.Header["X-Scal-Ring-Key"], "Not Found")
						case 412:
							goLog.Warning.Println(hostname, pid, url, resp.Status, "key=", resp.Header["X-Scal-Ring-Key"], "Does not exist")
						case 422:
							goLog.Error.Println(hostname, pid, url, resp.Status, resp.Header["X-Scal-Ring-Status"])
						default:
							goLog.Warning.Println(hostname, pid, url, resp.Status, "Elapse=", elapse)
							os.Exit(2) // metadata must be written first
						}

						resp.Body.Close()
					}
					if ok < req {
						goLog.Warning.Println(hostname, pid, docid, ok, req, "ok < req => Check Warning or Error log")

					}
				default:
					goLog.Warning.Println("Wrong request, please use -help to check the -a options")

				} // switch

				elapstm += elapse
				tok += int64(ok)
				treq += int64(req)

			} // loop on all pages of a document

			//elapstm0 := float64(elapstm) / 1000000.0
			total_size += doc_size
			doc_size0 := doc_size / 1000
			notok := pages_to_write - pages_written
			avg_elapstm := time.Duration(int64(elapstm) / int64(numdomain))
			if excel == "0" {
				goLog.Info.Println(hostname, pid, action, pathy[0], "doc_size=", doc_size0, "doc_pages=", t_pages, "domain=", domain0, "#domain=", numdomain, "Pages to writes/pages written=",
					pages_to_write, "/", pages_written, "notok=", notok, "elapstm=", elapstm, avg_elapstm)
			} else {

				goLog.Info.Printf("%s %d %s %s %d %d %s %d  %d %d %d %d %7.2f", hostname, pid, action, pathy[0], doc_size0, t_pages, domain0, numdomain,
					pages_to_write, pages_written, notok, int64(elapstm), float64(avg_elapstm)/1000000.0)

			}

			total_elapstm_since_start = time.Since(start)
			total_elapstm += elapstm
			elapstm = 0
			total_pages_to_write += int64(pages_to_write)
			total_pages_written += int64(pages_written)
			tok += int64(ok)

		} // Loop on all the documents

		//total_elapstm0 := float64(total_elapstm) / 1000000000.0
		total_size0 := total_size / 1000 // K
		var avg_page_elapstm time.Duration
		if total_pages_written > 0 {
			avg_page_elapstm = time.Duration(int64(total_elapstm) / total_pages_written)
		}

		if excel == "0" {
			goLog.Info.Println(hostname, pid, "End", action, application, "domain=", domain0, "#dom=", nDomain, "total docs=", total_docs, "total_pages=", total_pages, "total_sizes=", total_size0,
				"total_elapse=", total_elapstm, "/", total_elapstm_since_start, "avg_page_elapstm=", avg_page_elapstm, "pages to writes/pages written=", total_pages_to_write, "/", total_pages_written)
		} else {
			goLog.Info.Printf("%s %d %s %s %s %s %d %d %d %d %d %d %d %d", hostname, pid, action, application, domain0, nDomain, total_docs, total_pages, total_size0,
				int64(total_elapstm), int64(total_elapstm_since_start), avg_page_elapstm, total_pages_to_write, total_pages_written)
		}

	} else {
		goLog.Error.Println(container_path, "Container Directory is missing")
		os.Exit(2)
	}
}
